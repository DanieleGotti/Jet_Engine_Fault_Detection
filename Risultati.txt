%% PROGETTO ALES - REPLICAZIONE ESATTA & ANALISI (FOCUS SCENARIO 1)
% Reference: Chen, Patton, Zhang (1996)
% =========================================================================
% OBIETTIVO ESAME: 
% Mostrare il fallimento del filtro Standard nel caso del Guasto al Sensore 1
% e il successo del filtro Robusto nello stesso scenario.
% =========================================================================

clc; clear; close all;

%% 1. DATI E MATRICI (Dal Paper)

% --- MODELLO LINEARE ---
A = [-1.5581,  0.6925,  0.3974;
      0.2619, -2.2228,  0.2238;
      0       0      -10    ];
B = [0; 0; 10];
C = [1       0       0;
     0       1       0;
     0       0       1;
     0.55107 0.13320 0.30603;
     0.55217 0.13526 0.32912;
    -0.25693 -0.23625 0.61299];
[n, ~] = size(A); [p, ~] = size(C);

% --- ERRORE MODELLO (E*) E MODELLO DISTURBO (E1) ---
E_star = [1.3293  3.4440  0.1375 -5.1304 -1.7826 -1.8719;
          5.6812 -0.5281 -0.3385 -1.6193  0.5229  0;
          0       0       0       0       0       0     ];

E1 = [6.2006,  2.8639;
      4.1048, -4.3262;
      0,       0     ];

% --- FILTRO ROBUSTO (Parametri forniti) ---
H_paper = [ 0.6117, -0.1170, 0, 0.3215, 0.3220, -0.1295;
           -0.1170,  0.9382, 0, 0.0605, 0.0623, -0.1916;
            0,       0,      0, 0,      0,       0     ];
T_paper = [ 0, 0, -0.1251;
            0, 0,  0.0783;
            0, 0,  1.0000];
K_paper = [-0.0708,  0.0443,  0.5658,  0.1400,  0.1531,  0.3540;
            0.0443, -0.0277, -0.3540, -0.0876, -0.0958, -0.2215;
            0.5658, -0.3540, -4.5229, -1.1193, -1.2239, -2.8297];

%% 2. CALCOLI TEORICI

% A. Filtro Standard
pole = 3;
K_bfdf = (A + pole * eye(n)) * pinv(C);

% B. Filtro Robusto (K1 per NPD)
CE1 = C * E1;
A1 = A - E1 * inv(CE1' * CE1) * CE1' * C * A;
K1_calc = (A1 + pole * eye(n)) * pinv(C);

%% 3. SIMULAZIONE (FOCUS SU GUASTO 1)

dt = 0.001; T_sim = 8; time = 0:dt:T_sim; steps = length(time);
u_val = 0.20; fault_mag = 0.02; fault_time = 2.0;
dist_factor = 20.0; % Fattore di amplificazione errore modello

I_sens = eye(p);
Table1 = zeros(3,3); Table2 = zeros(3,3);

% Variabili per salvare i dati da plottare (Solo Scenario 1)
log_r_bfdf_plot = []; log_r_uio_plot = [];

fprintf('Simulazione in corso (Distortion = %.1f)...\n', dist_factor);

for s_fault = 1:3 
    x = zeros(n,1); x_hat_bfdf = zeros(n,1); z_uio = zeros(n,1);
    acc_bfdf = zeros(1,3); acc_uio = zeros(1,3); count = 0;
    
    temp_hist_bfdf = zeros(p, steps); temp_hist_uio = zeros(p, steps);
    
    for k = 1:steps
        % 1. DINAMICA REALE
        d_x = [x(1)^2; x(2)^2; x(3)^2; x(1)*x(2); x(1)*x(3); x(2)*x(3)];
        dx = A*x + B*u_val + (E_star * d_x) * dist_factor;
        x = x + dx * dt;
        
        y_raw = C*x;
        if time(k) >= fault_time, y_raw(s_fault) = y_raw(s_fault) + fault_mag; end
        
        % 2. FILTRO STANDARD
        r_bfdf = y_raw - C * x_hat_bfdf;
        dx_bfdf = A * x_hat_bfdf + B * u_val + K_bfdf * r_bfdf;
        x_hat_bfdf = x_hat_bfdf + dx_bfdf * dt;
        
        % 3. FILTRO ROBUSTO
        F_uio = A1 - K1_calc * C; 
        dz_uio = F_uio * z_uio + T_paper * B * u_val + K_paper * y_raw;
        z_uio = z_uio + dz_uio * dt;
        x_hat_uio = z_uio + H_paper * y_raw;
        r_uio = y_raw - C * x_hat_uio;
        
        % Logging
        temp_hist_bfdf(:,k) = r_bfdf; temp_hist_uio(:,k) = r_uio;
        
        % 4. NPD
        if time(k) > fault_time + 2.0
            count = count + 1;
            for j = 1:3
                Ij = I_sens(:,j);
                % Standard
                Phi = [Ij, C*K_bfdf(:,j)];
                P = Phi * pinv(Phi'*Phi) * Phi';
                r_p = P * r_bfdf;
                acc_bfdf(j) = acc_bfdf(j) + (norm(r_bfdf-r_p)/(norm(r_bfdf)+eps));
                % Robust
                Phi_r = [Ij, C*K1_calc(:,j), C*H_paper(:,j)];
                P_r = Phi_r * pinv(Phi_r'*Phi_r) * Phi_r';
                r_pr = P_r * r_uio;
                acc_uio(j) = acc_uio(j) + (norm(r_uio-r_pr)/(norm(r_uio)+eps));
            end
        end
    end
    Table1(:, s_fault) = acc_bfdf / count; 
    Table2(:, s_fault) = acc_uio / count;
    
    % Salviamo i dati se siamo nel CASO 1 (Quello che vogliamo plottare)
    if s_fault == 1
        log_r_bfdf_plot = temp_hist_bfdf;
        log_r_uio_plot = temp_hist_uio;
    end
end

%% 4. RISULTATI NUMERICI

fprintf('\n=== ANALISI CASO GUASTO SENSORE 1 ===\n');
fprintf('Realtà: Si è rotto il sensore 1.\n\n');

fprintf('TABELLA 1 (Standard):\n');
fprintf('Ipotesi 1 (NPD1): %.4f\n', Table1(1,1));
fprintf('Ipotesi 2 (NPD2): %.4f  <- MINIMO! (Diagnosi Errata)\n', Table1(2,1));
fprintf('Ipotesi 3 (NPD3): %.4f\n', Table1(3,1));

fprintf('\nTABELLA 2 (Robust):\n');
fprintf('Ipotesi 1 (NPD1): %.4f  <- MINIMO! (Diagnosi Corretta)\n', Table2(1,1));
fprintf('Ipotesi 2 (NPD2): %.4f\n', Table2(2,1));
fprintf('Ipotesi 3 (NPD3): %.4f\n', Table2(3,1));

%% 5. GRAFICI PRESENTAZIONE (FOCUS SCENARIO 1)

% --- GRAFICO A BARRE: IL FALLIMENTO ---
figure('Color','w','Position',[50 50 700 450]);

% Prendiamo la PRIMA COLONNA delle tabelle (Caso Fault 1)
data_bar = [Table1(:,1), Table2(:,1)]; 

b = bar(data_bar);
title({'FALLIMENTO DEL FILTRO STANDARD', 'Scenario Reale: Guasto Sensore 1'});
xlabel('Ipotesi del Filtro (Quale sensore è rotto?)'); 
ylabel('NPD (Minore = Più probabile)');
xticklabels({'Sensore 1', 'Sensore 2', 'Sensore 3'});
legend('Standard BFDF', 'Robust UIO', 'Location','NorthOutside');
grid on;

% Evidenziamo l'errore grafico
% Coordinata (2, ValoreNPD2_Standard) -> Lì c'è l'errore
x_wrong = 2 - 0.15; % Spostato un po' a sinistra sulla barra blu
y_wrong = Table1(2,1);
text(x_wrong, y_wrong, '\downarrow Standard: "È il 2!" (ERRORE)', ...
    'Vert','bottom', 'Horiz','center', 'Color','r', 'FontWeight','bold', 'FontSize',10);

% Evidenziamo la correttezza
x_right = 1 + 0.15; % Spostato a destra sulla barra arancio
y_right = Table2(1,1);
text(x_right, y_right, '\downarrow Robusto: "È l''1!" (CORRETTO)', ...
    'Vert','bottom', 'Horiz','center', 'Color','b', 'FontWeight','bold', 'FontSize',10);


% --- GRAFICO 3D: PERCHÉ FUNZIONA? ---
idx_st = find(time >= fault_time, 1);
r_b = log_r_bfdf_plot(1:3, idx_st:end);
r_u = log_r_uio_plot(1:3, idx_st:end);

figure('Color','w','Position',[800 50 800 500]);
subplot(1,2,1);
plot3(r_b(1,:), r_b(2,:), r_b(3,:), 'r'); grid on; axis equal; view(45,30);
title({'STANDARD BFDF', 'Residuo disperso (Nessuna direzione)'});
xlabel('r1'); ylabel('r2'); zlabel('r3');

subplot(1,2,2);
plot3(r_u(1,:), r_u(2,:), r_u(3,:), 'b', 'LineWidth',1.5); grid on; axis equal; view(45,30);
hold on;
% Disegniamo la direzione teorica ideale (Firma Guasto 1)
ideal_dir = C * K1_calc(:,1); 
scale = max(abs(r_u(:))) / max(abs(ideal_dir));
plot3([0 ideal_dir(1)*scale], [0 ideal_dir(2)*scale], [0 ideal_dir(3)*scale], 'k--', 'LineWidth', 2);
title({'ROBUST UIO', 'Allineato alla "Firma" (Tratteggiata)'});
xlabel('r1'); ylabel('r2'); zlabel('r3');
legend('Residuo Reale', 'Firma Teorica Guasto 1');