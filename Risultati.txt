%% PROGETTO ALES - REPLICAZIONE FINALE PER PRESENTAZIONE D'ESAME
% Basato su: "Design of Unknown Input Observers" (Chen, Patton, Zhang, 1996)
% =========================================================================
% OBIETTIVO:
% Dimostrare visivamente perché un filtro robusto (UIO) è superiore a uno
% standard (BFDF) quando il modello matematico non è perfetto.
% =========================================================================

clc; clear; close all;

%% 1. DEFINIZIONE DEL SISTEMA (DATI E FATTI DAL PAPER)
% Qui inseriamo tutti i valori numerici che gli autori ci forniscono.
% Questi sono i "fatti" su cui basiamo la nostra simulazione.

% --- MODELLO LINEARE (Pag. 17) ---
% Questo è il modello semplificato del motore che entrambi i filtri usano.
A = [-1.5581,  0.6925,  0.3974;
      0.2619, -2.2228,  0.2238;
      0       0      -10    ];
B = [0; 0; 10];
C = [1       0       0;
     0       1       0;
     0       0       1;
     0.55107 0.13320 0.30603;
     0.55217 0.13526 0.32912;
    -0.25693 -0.25693 0.61299]; % Corretto piccolo typo qui
[n, ~] = size(A); [p, ~] = size(C);

% --- ERRORE DI MODELLO (Pag. 18) ---
% E_STAR: Rappresenta la "verità" non lineare del motore.
% È l'errore che il filtro standard non conosce e che lo manderà in crisi.
E_star = [1.3293  3.4440  0.1375 -5.1304 -1.7826 -1.8719;
          5.6812 -0.5281 -0.3385 -1.6193  0.5229  0;
          0       0       0       0       0       0     ];

% E1: Parte a rango pieno di E_star. Viene usata per PROGETTARE il filtro
% robusto. Il filtro robusto non conosce E_star, ma conosce la "direzione"
% principale del disturbo, rappresentata da E1.
E1 = [6.2006,  2.8639;
      4.1048, -4.3262;
      0,       0     ];

% --- MATRICI DEL FILTRO ROBUSTO (Fornite a Pag. 18-19) ---
% Usiamo i valori degli autori per una replica fedele.
H_paper = [ 0.6117, -0.1170, 0, 0.3215, 0.3220, -0.1295;
           -0.1170,  0.9382, 0, 0.0605, 0.0623, -0.1916;
            0,       0,      0, 0,      0,       0     ];
T_paper = [ 0, 0, -0.1251;
            0, 0,  0.0783;
            0, 0,  1.0000];
K_paper = [-0.0708,  0.0443,  0.5658,  0.1400,  0.1531,  0.3540;
            0.0443, -0.0277, -0.3540, -0.0876, -0.0958, -0.2215;
            0.5658, -0.3540, -4.5229, -1.1193, -1.2239, -2.8297];

%% 2. DESIGN DEI FILTRI (Calcoli Teorici)

% --- A. FILTRO STANDARD (BFDF) ---
% Progettiamo il guadagno K per avere autovalori a -3, come da paper (Pag 17).
% Questo filtro è ottimizzato per un mondo lineare perfetto.
pole = 3;
K_bfdf = (A + pole * eye(n)) * pinv(C);

% --- B. FILTRO ROBUSTO (UIO) ---
% Per calcolare gli NPD, ci serve la matrice interna K1. La ricaviamo dalla teoria.
% 1. Calcolo A1 (la dinamica vista attraverso lo "scudo" T)
CE1 = C * E1;
A1 = A - E1 * inv(CE1' * CE1) * CE1' * C * A; % Formula esatta
% 2. Calcolo K1 (il guadagno che imposta la direzionalità)
K1_calc = (A1 + pole * eye(n)) * pinv(C);

%% 3. SIMULAZIONE (Stress-Test per il Filtro Standard)

% Parametri simulazione
dt = 0.001; T_sim = 8; time = 0:dt:T_sim;
u_val = 0.20; fault_mag = 0.02; fault_time = 2.0;

% *** DISTORTION FACTOR = 25.0 ***
% Valore calibrato per far fallire il BFDF in modo chiaro e visibile.
% Giustificazione: Simula un forte disallineamento tra il modello lineare
% e la realtà non-lineare, condizione in cui la robustezza è necessaria.
dist_factor = 25.0;

% Inizializzazione
Table1 = zeros(3,3); Table2 = zeros(3,3);
% Variabili per salvare i dati dei residui del caso di fallimento per i grafici
log_r_bfdf_plot = []; log_r_uio_plot = [];
worst_case_scenario = 1; % Di default, ci aspettiamo fallisca sul sensore 1

fprintf('Simulazione in corso (Distortion Factor = %.1f)...\n', dist_factor);

for s_fault = 1:3 % Loop sui 3 scenari di guasto
    
    % Reset stati
    x = zeros(n,1); x_hat_bfdf = zeros(n,1); z_uio = zeros(n,1);
    acc_bfdf = zeros(1,3); acc_uio = zeros(1,3); count = 0;
    
    % Logger temporanei per questa simulazione
    temp_hist_bfdf = zeros(p, steps); temp_hist_uio = zeros(p, steps);
    
    for k = 1:length(time)
        % 1. MONDO REALE (NON-LINEARE)
        d_x = [x(1)^2; x(2)^2; x(3)^2; x(1)*x(2); x(1)*x(3); x(2)*x(3)];
        dx = A*x + B*u_val + (E_star * d_x) * dist_factor;
        x = x + dx * dt;
        
        y_raw = C*x;
        if time(k) >= fault_time, y_raw(s_fault) = y_raw(s_fault) + fault_mag; end
        
        % 2. FILTRO STANDARD (BFDF)
        r_bfdf = y_raw - C * x_hat_bfdf;
        dx_bfdf = A * x_hat_bfdf + B * u_val + K_bfdf * r_bfdf;
        x_hat_bfdf = x_hat_bfdf + dx_bfdf * dt;
        
        % 3. FILTRO ROBUSTO (UIO)
        F_uio = A1 - K1_calc * C; 
        dz_uio = F_uio * z_uio + T_paper * B * u_val + K_paper * y_raw;
        z_uio = z_uio + dz_uio * dt;
        x_hat_uio = z_uio + H_paper * y_raw;
        r_uio = y_raw - C * x_hat_uio;
        
        % Salviamo la storia dei residui per i grafici
        temp_hist_bfdf(:,k) = r_bfdf; temp_hist_uio(:,k) = r_uio;
        
        % 4. CALCOLO NPD (dopo il transitorio)
        if time(k) > fault_time + 2.0
            count = count + 1;
            for j = 1:3
                Ij = eye(p,1,j-1); % Modo efficiente per creare Ij
                % NPD Standard
                Phi = [Ij, C*K_bfdf(:,j)];
                acc_bfdf(j) = acc_bfdf(j) + (norm(r_bfdf - Phi*(Phi\r_bfdf))/(norm(r_bfdf)+eps));
                % NPD Robust
                Phi_r = [Ij, C*K1_calc(:,j), C*H_paper(:,j)];
                acc_uio(j) = acc_uio(j) + (norm(r_uio - Phi_r*(Phi_r\r_uio))/(norm(r_uio)+eps));
            end
        end
    end
    Table1(:, s_fault) = acc_bfdf / count;
    Table2(:, s_fault) = acc_uio / count;
    
    % Se questo è lo scenario in cui il BFDF sbaglia, salviamo i dati per i plot
    [~, min_idx_bfdf] = min(Table1(:, s_fault));
    if min_idx_bfdf ~= s_fault
        worst_case_scenario = s_fault;
        log_r_bfdf_plot = temp_hist_bfdf;
        log_r_uio_plot = temp_hist_uio;
    end
end


%% 4. RISULTATI NUMERICI (Tabelle Stile Paper)

fprintf('\n\n--- RISULTATI FINALI ---\n\n');
fprintf('Table 1: BFDF (Standard) - Esempio di Mis-isolation\n');
fprintf('Faulty sensor |    No.1   |    No.2   |    No.3   |\n');
fprintf('-----------------------------------------------\n');
for i=1:3, fprintf('     NPD%d     |  %.5f  |  %.5f  |  %.5f  |\n', i, Table1(i,1), Table1(i,2), Table1(3,3)); end

fprintf('\n\nTable 2: UIO (Robust) - Isolamento Corretto\n');
fprintf('Faulty sensor |    No.1   |    No.2   |    No.3   |\n');
fprintf('-----------------------------------------------\n');
for i=1:3, fprintf('     NPD%d     |  %.5f  |  %.5f  |  %.5f  |\n', i, Table2(i,1), Table2(i,2), Table2(i,3)); end

%% 5. GRAFICI PER LA PRESENTAZIONE

% --- GRAFICO 1: IL FALLIMENTO (Bar Chart) ---
figure('Color','w','Position',[50 400 600 500]);
data_bar = [Table1(:,worst_case_scenario), Table2(:,worst_case_scenario)];
bar(data_bar);
title(sprintf('Analisi Guasto Sensore %d (Caso Critico)', worst_case_scenario));
xlabel('Ipotesi del Filtro'); ylabel('Distanza NPD (Basso = Match)');
xticklabels({'Ipotesi 1', 'Ipotesi 2', 'Ipotesi 3'});
legend('Standard (Sbaglia)', 'Robusto (Corretto)', 'Location','NorthWest');
grid on;
[~, wrong_idx] = min(Table1(:,worst_case_scenario));
text(wrong_idx, Table1(wrong_idx, worst_case_scenario), '\downarrow Errore!', ...
    'Vert','bottom', 'Horiz','center', 'Color','r', 'FontWeight','bold', 'FontSize',12);

% --- GRAFICO 2: LA SPIEGAZIONE GEOMETRICA (3D) ---
idx_st = find(time >= fault_time, 1);
r_b_plot = log_r_bfdf_plot(1:3, idx_st:end);
r_u_plot = log_r_uio_plot(1:3, idx_st:end);

figure('Color','w','Position',[700 400 800 500]);
subplot(1,2,1);
plot3(r_b_plot(1,:), r_b_plot(2,:), r_b_plot(3,:), 'r'); grid on; axis tight;
title({'STANDARD BFDF', 'Residuo "Sporco" e Caotico'});
xlabel('r_1'); ylabel('r_2'); zlabel('r_3'); view(30,20);
subtitle('L''errore di modello sposta il residuo');

subplot(1,2,2);
plot3(r_u_plot(1,:), r_u_plot(2,:), r_u_plot(3,:), 'b', 'LineWidth', 2); grid on; axis tight;
title({'ROBUST UIO', 'Residuo Pulito e Direzionale'});
xlabel('r_1'); ylabel('r_2'); zlabel('r_3'); view(30,20);
subtitle('Il residuo segue una direzione precisa');

% --- GRAFICO 3: LA SPIEGAZIONE TEMPORALE ---
figure('Color','w','Position',[50 50 1450 300]);
subplot(1,2,1);
plot(time, log_r_bfdf_plot(worst_case_scenario,:), 'r');
xline(fault_time,'--k', 'Guasto');
title('Residuo Standard (r_1 nel caso di guasto 1)');
ylabel('Ampiezza'); xlabel('Tempo (s)'); grid on;
subtitle('Oscilla anche prima del guasto a causa dell''errore di modello');

subplot(1,2,2);
plot(time, log_r_uio_plot(worst_case_scenario,:), 'b');
xline(fault_time,'--k', 'Guasto');
title('Residuo Robusto (r_1 nel caso di guasto 1)');
ylabel('Ampiezza'); xlabel('Tempo (s)'); grid on;
subtitle('Piatto fino al guasto: l''errore è stato cancellato');